# -*- coding: utf-8 -*-
"""PriyaSethi_ECE-2_09511502820_Churn.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1MASGhAc7frk1dVm7h0Ozz-Z0xS7mAicH
"""

path='/content/drive/MyDrive/Datasets/Churn_Modelling.csv'

from google.colab import drive
drive.mount('/content/drive')

# Commented out IPython magic to ensure Python compatibility.
import pandas as pd
from matplotlib import pyplot as plt
import numpy as np
import tensorflow as tf
from tensorflow import keras
# %matplotlib inline

df = pd.read_csv(path)

df.head()

df.shape

df.dtypes

df.isnull().sum()

df['Exited'].value_counts()

churn_exited = df[df['Exited']==1]['Tenure']
churn_not_exited = df[df['Exited']==0]['Tenure']

def visualize(x, y, xlabel):
  plt.figure(figsize=(10,5))
  plt.hist([x,y], color=['red','green'],label=['exit', 'not exit'])
  plt.xlabel(xlabel)
  plt.ylabel("No. of Customers")
  plt.legend()

visualize(churn_exited, churn_not_exited, "Tenure")

df.drop(['RowNumber','Surname'], axis='columns', inplace=True)

df.head()

df.Geography.unique()

df.Gender.unique()

df['Gender'].replace(['Male','Female'],[1,0], inplace=True)

df.dtypes

df.head()

df=pd.get_dummies(data=df, columns=['Geography'])
df.columns

cols=['CustomerId','CreditScore','Age','Tenure','Balance','NumOfProducts','EstimatedSalary']

from sklearn.preprocessing import MinMaxScaler
scaler=MinMaxScaler()
df[cols]=scaler.fit_transform(df[cols])

df.head()

x=df.drop('Exited', axis='columns')
y=df['Exited']

from sklearn.model_selection import train_test_split
x_train, x_test, y_train, y_test = train_test_split(x,y, test_size = 0.2, random_state=1)

model = keras.Sequential([
    keras.layers.Dense(13, input_shape=(13,), activation='relu'),
    keras.layers.Dense(15, activation='relu'),
    keras.layers.Dense(1, activation='sigmoid')
    ])

model.compile(optimizer='SGD', loss='binary_crossentropy', metrics=['accuracy'])
model.fit(x_train, y_train, epochs=100)

yp=model.predict(x_test)

from sklearn.metrics import confusion_matrix, classification_report

y_pred=[]
for element in yp:
  if element > 0.5:
    y_pred.append(1)
  else:
    y_pred.append(0)

print(classification_report(y_test, y_pred))

